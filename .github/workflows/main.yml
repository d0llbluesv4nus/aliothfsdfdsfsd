name: Poco F3 ROM Port (FIXED TOOLS)

on:
  workflow_dispatch:
    inputs:
      stock_url:
        description: 'STOCK Fastboot ROM (alioth)'
        required: true
      port_url:
        description: 'PORT Fastboot ROM (donor)'
        required: true
      rom_name:
        description: 'ZIP name'
        default: 'Alioth_Port_Release'

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # 1. Очистка места (30+ GB)
      - name: Free Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: false

      # 2. Установка инструментов
      - name: Install tools
        run: |
          sudo apt-get update
          # erofs-utils уже есть в репозитории Ubuntu 22.04+, компиляция не нужна!
          sudo apt-get install -y aria2 p7zip-full git file unzip \
            android-sdk-libsparse-utils erofs-utils \
            build-essential liblz4-dev liblzma-dev uuid-dev e2fsprogs

          # Утилита lpunpack (LineageOS 21 - OK)
          wget https://raw.githubusercontent.com/LineageOS/android_prebuilts_extract-tools/lineage-21.0/linux-x86/bin/lpunpack
          chmod +x lpunpack && sudo mv lpunpack /usr/local/bin/

          # Утилита make_ext4fs (LineageOS 18.1 - В 21 версии её удалили, поэтому была ошибка 404!)
          wget https://raw.githubusercontent.com/LineageOS/android_prebuilts_extract-tools/lineage-18.1/linux-x86/bin/make_ext4fs
          chmod +x make_ext4fs && sudo mv make_ext4fs /usr/local/bin/

          # Magiskboot (Официальный APK)
          wget https://github.com/topjohnwu/Magisk/releases/download/v27.0/Magisk-v27.0.apk
          unzip Magisk-v27.0.apk -d magisk
          cp magisk/lib/x86_64/libmagiskboot.so magiskboot
          chmod +x magiskboot && sudo mv magiskboot /usr/local/bin/
          rm -rf magisk Magisk-v27.0.apk

          echo "✅ Все инструменты установлены."

      - name: Prepare workspace
        run: mkdir -p workspace/{stock,port,final/images,assets,checks}

      # 3. Обработка STOCK
      - name: Process STOCK
        run: |
          cd workspace/stock
          echo ">>> Скачивание стока..."
          aria2c -x4 -s4 "${{ inputs.stock_url }}" -o stock.tgz
          
          echo ">>> Распаковка tar..."
          tar -xf stock.tgz
          rm stock.tgz

          # Заходим внутрь папки с прошивкой (Xiaomi кладет файлы в подпапку)
          # Находим папку images где бы она ни была
          IMG_DIR=$(find . -type d -name "images" | head -n1)
          if [ -z "$IMG_DIR" ]; then
             # Если папки images нет, возможно файлы в корне (редко)
             IMG_DIR=$(find . -name "boot.img" -printf "%h\n" | head -n1)
          fi
          
          echo ">>> Переход в директорию образов: $IMG_DIR"
          cd "$IMG_DIR"

          # Проверяем Super
          SUPER=$(find . -name "super.img" | head -n1)
          if [ -f "$SUPER" ]; then
             echo ">>> Распаковка super.img..."
             simg2img "$SUPER" super.raw
             lpunpack super.raw .
             rm super.raw
          fi

          # Копируем нужные файлы в папку сборки
          echo ">>> Копирование boot/vendor/etc..."
          cp boot.img ../../final/images/
          cp dtbo.img ../../final/images/
          cp vbmeta.img ../../final/images/
          
          # Если vendor был в super, он уже здесь. Если отдельным файлом - тоже здесь.
          # Берем самый большой файл (защита от пустышек _b)
          VENDOR=$(ls -S vendor*.img | head -1)
          cp "$VENDOR" ../../final/images/vendor.img
          
          # Для определения FS смотрим на product
          PRODUCT=$(ls -S product*.img | head -1)
          
          if fsck.erofs --extract=product_fs "$PRODUCT"; then
             echo "STOCK_FS=erofs" >> $GITHUB_ENV
             echo ">>> Сток использует EROFS"
          else
             echo "STOCK_FS=ext4" >> $GITHUB_ENV
             echo ">>> Сток использует EXT4"
             # Если это ext4, распакуем 7z
             7z x "$PRODUCT" -oproduct_fs
          fi

          # Сохраняем fstab из стока (важно для монтирования!)
          echo ">>> Поиск fstab..."
          find product_fs -name "fstab.*" -exec cp {} ../../assets/ \; || true
          
          # Удаляем распакованный сток для экономии места
          rm -rf product_fs

      # 4. Обработка PORT
      - name: Process PORT & Repack
        run: |
          cd workspace/port
          echo ">>> Скачивание порта..."
          aria2c -x4 -s4 "${{ inputs.port_url }}" -o port.tgz
          
          tar -xf port.tgz
          rm port.tgz

          # Ищем папку с образами
          IMG_DIR=$(find . -type d -name "images" | head -n1)
          if [ -z "$IMG_DIR" ]; then IMG_DIR=$(find . -name "system.img" -printf "%h\n" | head -n1); fi
          
          # Если system.img нет, ищем в super
          if [ -z "$IMG_DIR" ]; then
             IMG_DIR=$(find . -name "super.img" -printf "%h\n" | head -n1)
          fi
          
          cd "$IMG_DIR"
          
          SUPER=$(find . -name "super.img" | head -n1)
          if [ -f "$SUPER" ]; then
             simg2img "$SUPER" super.raw
             lpunpack super.raw .
             rm super.raw
          fi

          # Функция перепаковки
          repack() {
            NAME=$1
            # Ищем самый большой файл (фильтруем пустышки)
            # Исключаем system_ext когда ищем system
            if [ "$NAME" == "system" ]; then
               IMG=$(ls -S system.img system_a.img 2>/dev/null | head -1)
            else
               IMG=$(ls -S ${NAME}*.img 2>/dev/null | head -1)
            fi

            if [ -f "$IMG" ]; then
               echo ">>> Processing $NAME ($IMG)..."
               rm -rf extracted && mkdir extracted
               
               # Распаковка (пробуем EROFS, иначе 7z для EXT4)
               if ! fsck.erofs --extract=extracted "$IMG" 2>/dev/null; then
                  7z x "$IMG" -oextracted > /dev/null
               fi
               
               rm "$IMG" # Удаляем оригинал

               # Подкидываем fstab из стока (Fix Mount Errors)
               if [ -f ../../assets/fstab.qcom ]; then
                  echo "   -> Injecting stock fstab..."
                  find extracted -name "fstab.*" -delete
                  # Обычно fstab лежит в vendor/etc или system/etc
                  cp ../../assets/fstab.* extracted/etc/ 2>/dev/null || true
                  mkdir -p extracted/vendor/etc 2>/dev/null || true
                  cp ../../assets/fstab.* extracted/vendor/etc/ 2>/dev/null || true
               fi

               # Собираем в нужный формат (как у стока)
               if [ "${{ env.STOCK_FS }}" = "erofs" ]; then
                  echo "   -> Repacking to EROFS (LZ4)..."
                  mkfs.erofs -zlz4 -C16384 ../../final/images/${NAME}.img extracted
               else
                  echo "   -> Repacking to EXT4..."
                  # Вычисляем размер: текущий + 150МБ запаса
                  SIZE=$(du -sm extracted | awk '{print $1+150}')M
                  make_ext4fs -s -L $NAME -l $SIZE -a $NAME ../../final/images/${NAME}.img extracted/
               fi
               
               rm -rf extracted
            fi
          }

          # Запускаем перепаковку для основных разделов
          repack system
          repack system_ext
          repack product
          repack mi_ext
          repack odm

      # 5. Патч boot (Hex Patch)
      - name: Patch boot (SELinux Permissive)
        run: |
          cd workspace/final/images
          if [ -f boot.img ]; then
             echo ">>> Patching boot.img kernel..."
             magiskboot unpack boot.img
             # Hexpatch: enforcing -> permissive
             if [ -f kernel ]; then
                magiskboot hexpatch kernel \
                73656C696E75783D656E666F7263696E67 \
                73656C696E75783D7065726D697373697665
             fi
             magiskboot repack boot.img
             mv new-boot.img boot.img
             rm -f kernel ramdisk.cpio dtb header
          fi

      # 6. Упаковка и релиз
      - name: Pack ZIP
        run: |
          cd workspace/final
          cat <<EOF > flash_all.bat
          @echo off
          fastboot flash boot images/boot.img
          fastboot flash dtbo images/dtbo.img
          fastboot flash vendor images/vendor.img
          if exist images\odm.img fastboot flash odm images/odm.img
          fastboot flash system images/system.img
          fastboot flash system_ext images/system_ext.img
          fastboot flash product images/product.img
          if exist images\mi_ext.img fastboot flash mi_ext images/mi_ext.img
          fastboot reboot
          pause
          EOF

          ZIP="${{ inputs.rom_name }}.zip"
          # Разбиваем архив на тома по 2GB (ограничение GitHub)
          7z a -tzip -mx1 -v2000m "$ZIP" .
          
          echo "TAG=v$(date +'%Y.%m.%d-%H%M')" >> $GITHUB_ENV

      - uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.TAG }}
          name: Alioth Port ${{ env.TAG }}
          files: workspace/final/${{ inputs.rom_name }}.zip.*
